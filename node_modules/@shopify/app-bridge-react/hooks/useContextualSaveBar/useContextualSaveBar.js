"use strict";
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.useContextualSaveBar = void 0;
var react_1 = require("react");
var ContextualSaveBar_1 = require("@shopify/app-bridge/actions/ContextualSaveBar");
var useAppBridge_1 = require("../../useAppBridge");
function useContextualSaveBar(_a) {
    var discardAction = _a.discardAction, saveAction = _a.saveAction, fullWidth = _a.fullWidth, leaveConfirmationDisable = _a.leaveConfirmationDisable, visible = _a.visible;
    var app = useAppBridge_1.useAppBridge();
    var onSaveAction = saveAction.onAction, saveActionProps = __rest(saveAction, ["onAction"]);
    var onDiscardAction = discardAction.onAction, discardActionProps = __rest(discardAction, ["onAction"]);
    /* We want to reuse the same ContextualSaveBar instance, even when props change
     * (so we don't include all the props in the dependency array).
     * Instead of recreating the component on every change, we use the set method,
     * in the useEffect block below, to dispatch updates when props change.
     */
    var contextualSaveBar = react_1.useMemo(function () {
        return ContextualSaveBar_1.create(app, {
            saveAction: saveActionProps,
            discardAction: discardActionProps,
            fullWidth: fullWidth,
            leaveConfirmationDisable: leaveConfirmationDisable,
        });
    }, [app]);
    react_1.useEffect(function () {
        contextualSaveBar.set({
            saveAction: saveActionProps,
            discardAction: discardActionProps,
            fullWidth: fullWidth,
            leaveConfirmationDisable: leaveConfirmationDisable,
        }, Boolean(visible));
    }, [
        contextualSaveBar,
        saveActionProps,
        discardActionProps,
        fullWidth,
        leaveConfirmationDisable,
        visible,
    ]);
    react_1.useEffect(function () {
        contextualSaveBar.subscribe(ContextualSaveBar_1.Action.DISCARD, onDiscardAction);
        contextualSaveBar.subscribe(ContextualSaveBar_1.Action.SAVE, onSaveAction);
        return function () {
            contextualSaveBar.unsubscribe();
        };
    }, [contextualSaveBar]);
    react_1.useEffect(function () {
        if (visible) {
            contextualSaveBar.dispatch(ContextualSaveBar_1.Action.SHOW);
        }
        else {
            contextualSaveBar.dispatch(ContextualSaveBar_1.Action.HIDE);
        }
    }, [contextualSaveBar, visible]);
    return null;
}
exports.useContextualSaveBar = useContextualSaveBar;
